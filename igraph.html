<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
因为要做团伙分析，所以用到了igraph包，如果点在百个以内的话，可以清晰的画出关系图，但是我分析的是3K的数据量，画出来的就是一坨密密麻麻的图，因为涉及公司业务，我就简单写写分析的代码吧

底层数据集是每个点对应每个点，他们有他们的关联条件，然后输入进去


```
library("igraph")  
th <- read.table("alipowerid.txt",header=T)  
d  <- data.frame(p=th[,1],p2=th[,2])  
g  <- graph.data.frame(d,directed=F)  
```

这样相当于只要每个点和每个点之间连接了起来

接下就可以画图了

```
plot(g)
```

通过函数
```
clusters(g)
```

这个分类就是把只要有关联的人就算在了一个分类里面，我们知道根据六度分割原理，一个人和另一个只要通过中间的6个人就可以连载一起，所以说简单的把这样的算在一类里面是不科学的。
但是如果做一些简单的聚合是可以的

这其中也有一些技巧
```
V(g)$name[get.shortest.paths(g,  input$Point1 , input$Point2)$vpath[[1]]]  
```

这是每个点到每个点的最短距离（最短距离要是不止一条怎么破），其中

```
V(g)  
  
[1]Vertex sequence: 
```

这种格式是没办法写出到本地的必须加一个V(g)$name

```
V(g)$name
```
一一对应的


因为每个点的属性有两个属性，只要读入对应表，就可以输入一个属性，连个属性的最短路径就可以显示出来

```
dy <- read.table('duiying.txt',header=T,sep=',',fileEncoding="UTF-8")  
f <- function(x,y){ path1 <- V(g)$name[get.shortest.paths(g,x,y)$vpath[[1]]]  
                    index1 <- which(dy$alipay_id %in% path1 )  
                    nickpath <- dy$tb_nick[index1]  
                    print(as.vector(nickpath))  
                    print(path1)  
}  
```

接下来是对寻找具有中介位置的人

有个统计量叫做**中间度统计量**

>通过结点 K 的最短路径数称为节点 K 的绝对中介度(Betweenness)。由公式(2)定义的小于 1 的非负数称 CB(K)为节点 K 的相对中介度， 简称中介度。其中 g(i,j)是一个二值变量,表示结点 i,j 之间的最短路径是否通过结点 k,通过 k 则为 1,否则为 0 

```
V(g)$bte = betweenness(g, directed = F)  
## png("net_betweenness.png", width = 500, height = 500)  
par(mar = c(0, 2, 0, 0))  
plot(V(g)$bte)  
```

中间度越大的具有间接位置越大



**参考资料**

- 基于社会网络最短路径挖掘犯罪集团核心       温粉莲 唐常杰 乔少杰 许刚 刘威 左劼
- [社会网络分析：探索人人网好友推荐系统](http://cos.name/2011/04/exploring-renren-social-network/)
- [初次尝试igraph包](http://xccds1977.blogspot.com/2012/06/igraph.html)
- [iGraph——图挖掘助力社会网络分析](http://www.ituring.com.cn/article/1762)
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>因为要做团伙分析，所以用到了igraph包，如果点在百个以内的话，可以清晰的画出关系图，但是我分析的是3K的数据量，画出来的就是一坨密密麻麻的图，因为涉及公司业务，我就简单写写分析的代码吧</p>

<p>底层数据集是每个点对应每个点，他们有他们的关联条件，然后输入进去</p>

<pre><code>library("igraph")  
th &lt;- read.table("alipowerid.txt",header=T)  
d  &lt;- data.frame(p=th[,1],p2=th[,2])  
g  &lt;- graph.data.frame(d,directed=F)  
</code></pre>

<p>这样相当于只要每个点和每个点之间连接了起来</p>

<p>接下就可以画图了</p>

<pre><code>plot(g)
</code></pre>

<p>通过函数</p>

<pre><code>clusters(g)
</code></pre>

<p>这个分类就是把只要有关联的人就算在了一个分类里面，我们知道根据六度分割原理，一个人和另一个只要通过中间的6个人就可以连载一起，所以说简单的把这样的算在一类里面是不科学的。
但是如果做一些简单的聚合是可以的</p>

<p>这其中也有一些技巧</p>

<pre><code>V(g)$name[get.shortest.paths(g,  input$Point1 , input$Point2)$vpath[[1]]]  
</code></pre>

<p>这是每个点到每个点的最短距离（最短距离要是不止一条怎么破），其中</p>

<pre><code>V(g)  

[1]Vertex sequence: 
</code></pre>

<p>这种格式是没办法写出到本地的必须加一个V(g)$name</p>

<pre><code>V(g)$name
</code></pre>

<p>一一对应的</p>

<p>因为每个点的属性有两个属性，只要读入对应表，就可以输入一个属性，连个属性的最短路径就可以显示出来</p>

<pre><code>dy &lt;- read.table('duiying.txt',header=T,sep=',',fileEncoding="UTF-8")  
f &lt;- function(x,y){ path1 &lt;- V(g)$name[get.shortest.paths(g,x,y)$vpath[[1]]]  
                    index1 &lt;- which(dy$alipay_id %in% path1 )  
                    nickpath &lt;- dy$tb_nick[index1]  
                    print(as.vector(nickpath))  
                    print(path1)  
}  
</code></pre>

<p>接下来是对寻找具有中介位置的人</p>

<p>有个统计量叫做<strong>中间度统计量</strong></p>

<blockquote>
  <p>通过结点 K 的最短路径数称为节点 K 的绝对中介度(Betweenness)。由公式(2)定义的小于 1 的非负数称 CB(K)为节点 K 的相对中介度， 简称中介度。其中 g(i,j)是一个二值变量,表示结点 i,j 之间的最短路径是否通过结点 k,通过 k 则为 1,否则为 0 </p>
</blockquote>

<pre><code>V(g)$bte = betweenness(g, directed = F)  
## png("net_betweenness.png", width = 500, height = 500)  
par(mar = c(0, 2, 0, 0))  
plot(V(g)$bte)  
</code></pre>

<p>中间度越大的具有间接位置越大</p>

<p><strong>参考资料</strong></p>

<ul>
<li>基于社会网络最短路径挖掘犯罪集团核心       温粉莲 唐常杰 乔少杰 许刚 刘威 左劼</li>
<li><a href="http://cos.name/2011/04/exploring-renren-social-network/">社会网络分析：探索人人网好友推荐系统</a></li>
<li><a href="http://xccds1977.blogspot.com/2012/06/igraph.html">初次尝试igraph包</a></li>
<li><a href="http://www.ituring.com.cn/article/1762">iGraph——图挖掘助力社会网络分析</a></li>
</ul>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "igraph.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
</body>
</html>
